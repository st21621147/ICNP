\section{Adaptive Wildlife Encounter protocol}
\label{sectionmodel}

In this section, we introduce our Adaptive Wildlife Encounter~(AWE) protocol.
The pseudo-code of the protocol is given in Algorithm~\ref{DA} and Algorithm~\ref{CA}.

{\pName} consists of two stages: detecting stage and 
connecting stage. 
\begin{itemize}
    \item \textbf{Stage 1: detecting stage.} In this stage, an agent attempts to
    detect whether there are nearby peers, regardless of who they are. 
    \item \textbf{Stage 2: connecting stage} In this stage, an agent attempts to 
    identify the nearby peer(s) and record the encounter process to its log.
\end{itemize}

Initially, each agent starts from the detecting stage. 
In the detecting stage, an agent turns its radio to the $Sleep$ state most of the time,
and switches to $Transmit$ state and $Listen$ state at intervals.
In the connecting stage, agents only switch between $Transmit$ state 
and $Listen$ state.

The key idea of {\pName} is that, any single agent keeps in detecting 
stage to reduce ineffective energy consumption. When encounter happens, 
it detects the existence of nearby peers and turns to the connecting stage 
to identify those peers (or a peer) and record the encounter process to its log. 
After the encounter process is finished, the agent turns back to the detecting stage.

\begin{remark}
    In the {\pName} protocol, there is no need to synchronize the stage between agents.
    For example, two agents encounter at first and both turn to the connecting stage,
    then a peer come nearby them starting from the detecting stage. 
    {\pName} still works in this case. The proof of correctness will be presented 
    in section~\ref{sectionanalysis}. 
\end{remark}

In the following subsections, we describe the operations of these two stages in detail. 

\subsection{Detecting stage}

In the detecting stage, every $T_1$ time slots is a complete round.
Energy efficiency is achieved by the duty cycle mechanism, 
e.g., denote the predefined duty cycle for 
all the agents is $\theta$, the tag radio of each agent will work
$\theta T_1$ time slots in every period of $T_1$. However, it is very ineffective
when two agents encounter and one is in $Sleep$ state while the other is transmitting
or listening. 

To technically achieve synchronizing the time that agents turn on the radio,
we first introduce the Relax Difference Set (RDS).
We use the RDS technique to guarantee that every encounter pair 
of agents turn on the radio in the same time slot at least once in each round $T_1$.

RDS is an efficient tool to construct cyclic quorum systems. 
The definition is:
\begin{definition}
A set $R=\{a_1,a_2,...,a_k\} \subseteq Z_T$ (the set of all non-negative integers less than $T$)
is called a RDS if for every $d \neq 0$ (mod $T$),
there exists at least one ordered pair $(a_i,a_j)$ such that $a_i - a_j \equiv d$ (mod $T$), 
where $a_i,a_j \in D$.
\end{definition}

We now give an example to explain how RDS works to help synchronization, 
as depicted in Figure~\ref{} (TBD).
Suppose the duty cycle is set as $0.4$, i.e., there are four active slots 
in every $10$ time slots. it is easy to show that $R=\{1,2,3,6\}$ is a RDS
under $Z_{10}$:
\begin{align*}
    &2 - 1 = 1,\quad 3 - 1 = 2,\quad 6 - 3 = 3,\quad 6 - 2 = 4, \\
    &6 - 1 = 5,\quad {2 - 6 = 6}~{(mod~10)},\quad \dots,\quad \dots, 
\end{align*}
In every round of $10$ time slots, for any $i = \{0,1,\dots,9\}$, if $i \in R$, then
the agent turns on its radio in the $i^{th}$ slot in this round; otherwise it turns to the $Sleep$ state.
Consider any two agents in the detecting stage: if the time drift between their time rounds is $\delta$,
there exists at least one ordered pair $(a_i,a_j)$ in $R$ such that $a_i - a_j \equiv \delta$ (mod $10$).
That is, in each period $T_1$, any two agents at least once turn on the radio in the same time slot.

\begin{algorithm}[!h]
    \caption{RDS Construction Algorithm}
    \label{RDS}
    \begin{algorithmic}[1]
    \STATE $R :=\emptyset$; $\lambda :=\lceil \sqrt{T}  \rceil$,
    $\mu :=\lceil \frac{\lceil \sqrt{T} \rceil}{2} \rceil$;\label{RDSline1}
    \FOR{$i = 1 :\lambda$}
        \STATE $R :=R \cup i$; \label{RDSline2}
    \ENDFOR
    \FOR{$j = 1 :\mu$}
        \STATE $R :=R \cup (1 + j * \lambda )$; \label{RDSline3}
    \ENDFOR
    \end{algorithmic}
\end{algorithm}

It has been proved that any RDS must have cardinality $|R| \geq \sqrt{T}$\cite{luk1997two}.
We present a linear algorithm to construct a RDS with 
cardinality $\lceil \frac{3\sqrt{T}}{2}  \rceil$ under $Z_T$ in Alg. \ref{RDS}.

We show the correctness of the construction formally.
%The correctness proof of the construction
\begin{lemma}
\label{RDS1}
Set $R = \{r_0, r_1, ..., r_{\lambda + \mu - 1}\}$ constructed in Alg. \ref{RDS} is a RDS,
where $|R| = \lambda + \mu = \lceil \sqrt{N}  \rceil + \lceil \frac{\lceil \sqrt{N} \rceil}{2} \rceil
\approx \lceil \frac{3\sqrt{N}}{2}  \rceil$.
\end{lemma}
\begin{IEEEproof}
Obviously, if there exists one ordered pair $(a_i,a_j)$ satisfying  $a_i - a_j \equiv d$ (mod $N$),
an opposing pair $(a_j,a_i)$ exists such that
$a_j - a_i \equiv (N-d)$ (mod $N$). Thus we only need to find
at least one ordered pair $(a_i,a_j)$ for each $d \in [1, \lfloor N/2 \rfloor]$.

In the construction, $\lambda$ in Line \ref{RDSline1} is the smallest integer satisfying
$\lambda^2 \geq N$. Every $d$ within range $[1, \lfloor N/2 \rfloor]$
can be represented as: $ d = 1 + j \times \lambda - i$, where $1 \leq j \leq \mu,
1 \leq i \leq \lambda$. Thus, there exists $a_j = 1 + j \times \lambda$
from Line. \ref{RDSline2} and $a_i = i$ from Line. \ref{RDSline3}
satisfying  $a_j - a_i \equiv d$. Then, the lemma can be derived.
\end{IEEEproof}

\begin{algorithm}[!h]
    \caption{Detecting Algorithm}
    \label{DA}
    \begin{algorithmic}[1]
    \STATE $T := \lceil \frac{9}{4\theta^{2}} \rceil$; $\omega :=\frac{1}{2}$; $t := 0$;
    \STATE Invoke Alg.~\ref{RDS} to construct $R = \{r_0, r_1, ...,r_{\lceil 
    \frac{3\sqrt{T}}{2}  \rceil}\}$ under $Z_T$;
    \WHILE {$True$}
            \IF{$(t + 1) \in R$}
                \STATE Generate a random float $\rho \in (0,1)$;
                \IF{$\rho < \omega$}
                    \STATE Transmit a beacon;
                \ELSE
                    \STATE Listening;
                    \IF{Detects~energy~(a~beacon~or~a~collision~by~multiple~beacons)} 
                        \STATE Turn to \textbf{Connecting Stage};
                    \ENDIF
                \ENDIF
        \ELSE
                \STATE $Sleep$;
        \ENDIF
        \STATE $t := (t + 1) \% T$;
    \ENDWHILE
    \end{algorithmic}
\end{algorithm}

Based on the RDS, we present the operations in the detecting stage as Alg.~\ref{DA}.
An agent turns on its radio according to the RDS sequence and in each active slot it
transmits a beacon with probability $\omega$ and listen with probability $1-\omega$.
As discussed before, the aim of this stage is to detect nearby peer(s) as fast as possible 
(if exists), and either successful transmission or detecting collisions activate the agent
to the connecting stage. Here we fix the transmitting probability as $\omega = \frac{1}{2}$ 
since it is the optimal probability for two-agent encounter, the most common case
in the {\sysname} system (??Not sure). 
\begin{remark}
    Though $\omega = \frac{1}{2}$ is not the optimal probability in multi-agent encounter cases, 
    the probability that an agent detects a peer in a time slot grows as the number of agents
    increases. This is because a new agent will not interrupt but help other agents to detect peers
    if it is in $Transmit$ state in a time slot.
\end{remark}

\subsection{Connecting stage}

In the connecting stage, agents attempt to identify the nearby 
peers and record the encounter to its log.
A successful identification happens only if the agent is listening
and only one peer is transmitting. 

\begin{algorithm}[!h]
    \caption{Connecting Algorithm}
    \label{CA}
    \begin{algorithmic}[1]
    \STATE $t := 0$; $\omega := \frac{1}{2}$; $\epsilon$;
    \WHILE {$True$}
        \STATE \textbf{\emph{In the first sub-slot:}}
        \STATE Transmit a message containing ID with probability $\omega$
        and listen with probability $1-\omega$;
        \STATE \textbf{\emph{In the second sub-slot:}}
        \IF{the agent is in $Listen$ state in the first sub-slot}
            \IF{reveive a message successfully}
                \STATE Record the source ID and transmit a beacon;
            \ELSIF{channel is idle}
                \STATE $\omega := min\{(1+\epsilon)\omega, \zeta\}$;
            \ENDIF
        \ELSE
            \IF{detect energy}
                \STATE Keep listening in all the rest time slots of this round;
            \ELSE
                \STATE $\omega := \frac{\omega}{(1+\epsilon)}$;
            \ENDIF
        \ENDIF
        \STATE $t := (t + 1)$;
        \IF{$t == T$}
            \IF{no peer is found in this round}
                \STATE Turn to \textbf{Detecting Stage};
            \ELSE
                \STATE $t := 0$; $\omega := \frac{1}{2}$;
            \ENDIF
        \ENDIF
    \ENDWHILE
    \end{algorithmic}
\end{algorithm}



The collision detection (CD) mechanism is incorporated in this stage 
to increase of efficiency. This mechanism enables the listening agent 
to notify its transmitting peers of the transmission outcomes, 
and hence they take measures to reduce the collisions.

Each time slot is divided into two sub-slots and every 
$T_2$ complete time slots consists of a round.
Agents execute transmission or reception in the first sub-slot, 
and maintain the EncounterList and reply a beacon in the second sub-slot (if receive a message 
successfully in the first sub-slot). The algorithm in detecting stage is formulated as Alg.~\ref{CA}.

As discussed in section~\ref{sectionmodel}, $T_2$ is relatively short in 
real world, thus the communication connectivity stays stable in a round. 
However, due to the movements of agents, the communication connectivity
may change from round to round, so all the parameters will be 
initialized at the beginning of each round and adaptively adjusted later 
according to the transmission outcome.

Since the number of the nearby peers is unknown to each agent, 
the transmitting probability is initially set as $\frac{1}{2}$.
In the first sub-slot of each time slot, an agent transmit a message containing ID 
with probability $\omega$ and listen with probability $1 - \omega$. 

In the second sub-slot: 
\begin{itemize}
    \item[1)] The agent is in $Listen$ state in the first sub-slot:
    \begin{itemize}
    \item if the agent receives a message successfully, it 
    decodes and records the source ID in the message, and
    transmits a beacon (a bit is OK) as an acknowledgement 
    on the channel in the second sub-slot; 
    \item if the channel is idle, this means there is a chance to 
    transmit successfully and it multiplies its transmitting 
    probability by a factor $(1+\epsilon)$ (no larger than the pre-defined
    upper bound $\zeta$).
    \item if the agent detects collisions, it does nothing.
    \end{itemize}
    \item[2)] The agent is in $Transmit$ state in the first sub-slot:
    \begin{itemize}
    \item if the agent detects energy (beacon or collisions) in this sub-slot,
    this means its previous message has been successfully received by its nearby
    peers, and it keeps listening in all the rest time slots of this round.
    \item if the agent detects nothing in this sub-slot, it means ts previous message
    failed to propagate due to simultaneous transmitting. Thus it divides its transmitting 
    probability by a factor $(1+\epsilon)$. 
    \end{itemize}
\end{itemize}

In the end of a complete round, if there is no peer detected in this whole round, 
which indicates the encounter process is finished, the agent turns to the detecting stage .






% The key idea is that, since a round of time slots is very short 
% in real time, the nearby agents can be seen as a clique, i.e., 
% every two nodes are neighbors.  